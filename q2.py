import time
from collections import deque

def state_to_tuple(state):
    
    # Create rows of 3 characters each and convert each row into a tuple.
    return tuple(tuple(state[i*3+j] for j in range(3)) for i in range(3))

def tuple_to_state(matrix):
   
    return ''.join(''.join(row) for row in matrix)

def generate_moves(state):
    """
    Generate possible moves from the given state.
    Moves are generated by sliding the '0' (empty space) up, down, left, or right.
    Returns a list of new states (in tuple form) after valid moves.
    """
    moves = []
    rows = len(state)
    cols = len(state[0])
    print(rows,cols)
    found=False
    # Find the  empty tile '0'
    for i in range(rows):
        for j in range(cols):
            if state[i][j] == '0':
                emp_r, emp_c = (i, j)
                found = True
                break  # Break out of the inner loop
        if found:
            break  # Break out of the outer loop once found

    
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    for direction in directions:
        
            new_r = emp_r + direction[0]
            new_c = emp_c + direction[1]
            if new_r<3 and new_r>=0  and new_c<3 and new_c>=0:
                new_state_list = [list(row) for row in state]

                print(f"enpty row and col is: ",emp_r," ",emp_c)
                print(f"new row and col positoj is: ",new_r," ",new_c)

                # Swap the empty tile with the neighboring tile=
                new_state_list[emp_r][emp_c], new_state_list[new_r][new_c] =new_state_list[new_r][new_c], new_state_list[emp_r][emp_c]
                new_state = tuple(tuple(row) for row in new_state_list)
                moves.append(new_state)
    return moves

def dfs(start_state, goal_state):
    """
    Perform Depth-First Search (DFS) to find a solution path from start_state to goal_state.
    Both start_state and goal_state should be in tuple-of-tuples form.
    Returns the path as a list of states (each state is a tuple-of-tuples), or None if no solution exists.
    """
    # Use a stack where each element is (current_state, path_taken_so_far)
    stack = [(start_state, [start_state])]
    visited = set([start_state])
    
    
    while stack:
        current_state, path = stack.pop()
        print(f"current state: \n",current_state)
        if current_state == goal_state:
            return path
        # if current_state in visited:
        #     continue
        # visited.add(current_state)
        
        
        for neighbor in generate_moves(current_state):
            
            if neighbor not in visited:
                visited.add(neighbor)
                stack.append((neighbor, path + [neighbor]))
                
    
 
    return None

def main():
  
    start_state = input("Enter start State: ")  # e.g., "120345678"
    goal_state = input("Enter goal State: ")      # e.g., "012345678"
    
    start_tuple = state_to_tuple(start_state)
    goal_tuple = state_to_tuple(goal_state)
    
    print("-----------------")
    print("DFS Algorithm")
    print("-----------------")
    
    start_time = time.time()
    solution_path = dfs(start_tuple, goal_tuple)
    end_time = time.time()
    
    if solution_path:
        print("Time taken:", end_time - start_time, "seconds")
        print("Path Cost:", len(solution_path) - 1)  # cost is number of moves
        print("No of Nodes Visited:", len(solution_path))
        print("\nSolution Path:")
        for state in solution_path:
            for row in state:
                print(' '.join(row))
            print("-----")
    else:
        print("No solution found.")

if __name__ == "__main__":
    main()
