# -*- coding: utf-8 -*-
"""22l-6843-lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E7_jRdQ1U43ohXxaPR1Mo-nbFPErF8Qv
"""

#Q1

from collections import deque

def find_shortest_path(matrix):

    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]


    start = (0, 0)
    end = (3, 3)

    queue = deque([(start, [start])])
    visited = set()

    while queue:
        current, path = queue.popleft()


        if current == end:
            return path


        visited.add(current)


        for direction in directions:
            new_row = current[0] + direction[0]
            new_col = current[1] + direction[1]
            new_position = (new_row, new_col)

            if (0 <= new_row < len(matrix) and 0 <= new_col < len(matrix[0]) and
                new_position not in visited and matrix[new_row][new_col] != 1):
                queue.append((new_position, path + [new_position]))


    return None


matrix = [
    [0, 0, 0, 0],
    [0, 1, 1, 0],
    [1, 0, 0, 0],
    [0, 1, 1, 0]
]

path = find_shortest_path(matrix)
if path:
    print("Shortest Path:", path)
else:
    print("No path found.")

#Q2
import time

def convert_to_tuple(state):
    return tuple(tuple(int(state[i * 3 + j]) for j in range(3)) for i in range(3))

def convert_to_string(matrix):
    return ''.join(str(matrix[i][j]) for i in range(3) for j in range(3))

def locate_blank(matrix):
    for row in range(3):
        for col in range(3):
            if matrix[row][col] == 0:
                return row, col

def possible_moves(matrix):
    moves = []
    blank_row, blank_col = locate_blank(matrix)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for dr, dc in directions:
        new_row, new_col = blank_row + dr, blank_col + dc
        if 0 <= new_row < 3 and 0 <= new_col < 3:
            temp_matrix = [list(row) for row in matrix]
            temp_matrix[blank_row][blank_col], temp_matrix[new_row][new_col] = (
                temp_matrix[new_row][new_col],
                temp_matrix[blank_row][blank_col],
            )
            moves.append(tuple(tuple(row) for row in temp_matrix))
    return moves

def depth_first_search(start, goal):
    stack = [(start, [])]
    visited_states = set()

    while stack:
        current, path = stack.pop()

        if current == goal:
            return path

        visited_states.add(current)

        for move in possible_moves(current):
            if move not in visited_states:
                stack.append((move, path + [move]))

    return None

def main():
    start_input = input("Enter start State: ")
    goal_input = input("Enter goal State: ")

    start_state = convert_to_tuple(start_input)
    goal_state = convert_to_tuple(goal_input)

    print("-----------------")
    print("DFS Algorithm")
    print("-----------------")

    start_time = time.time()
    solution = depth_first_search(start_state, goal_state)
    end_time = time.time()

    if solution:
        print("Time taken:", end_time - start_time, "seconds")
        print("Path Cost:", len(solution))
        print("No of Nodes Visited:", len(solution) + 1)

        for state in solution:
            for row in state:
                print(' '.join(map(str, row)))
            print("------")
    else:
        print("No solution found.")

if __name__ == "__main__":
    main()

#Q3
from collections import defaultdict

class PathFinder:
    def __init__(self, graph_structure):
        self.graph_structure = graph_structure

    def find_neighbors(self, node):
        return self.graph_structure[node]

    def heuristic(self, node):
        heuristic_values = {
            "The": 4,
            "cat": 3,
            "dog": 3,
            "runs": 2,
            "fast": 1
        }
        return heuristic_values[node]

    def a_star_search(self, start, goal):
        open_set = set([start])
        closed_set = set([])

        cost_from_start = {}
        cost_from_start[start] = 0

        predecessors = {}
        predecessors[start] = None

        while len(open_set) > 0:
            current_node = None
            for node in open_set:
                if current_node is None or cost_from_start[node] + self.heuristic(node) < cost_from_start[current_node] + self.heuristic(current_node):
                    current_node = node

            if current_node is None:
                print("Path does not exist!")
                return None

            if current_node == goal:
                path = []
                while current_node is not None:
                    path.append(current_node)
                    current_node = predecessors[current_node]
                path.reverse()

                print("Sentence:", " -> ".join(path))
                print("Total cost:", cost_from_start[goal])
                return path

            for (neighbor, travel_cost) in self.find_neighbors(current_node):
                if neighbor not in open_set and neighbor not in closed_set:
                    open_set.add(neighbor)
                    predecessors[neighbor] = current_node
                    cost_from_start[neighbor] = cost_from_start[current_node] + travel_cost
                else:
                    if cost_from_start[neighbor] > cost_from_start[current_node] + travel_cost:
                        cost_from_start[neighbor] = cost_from_start[current_node] + travel_cost
                        predecessors[neighbor] = current_node

                        if neighbor in closed_set:
                            closed_set.remove(neighbor)
                            open_set.add(neighbor)

            open_set.remove(current_node)
            closed_set.add(current_node)

        print("Path does not exist!")
        return None


graph_structure = {
    "The": [("cat", 1), ("dog", 2)],
    "cat": [("runs", 2)],
    "dog": [("runs", 2)],
    "runs": [("fast", 1)],
    "fast": []
}

pathfinder = PathFinder(graph_structure)
pathfinder.a_star_search("The", "fast")

